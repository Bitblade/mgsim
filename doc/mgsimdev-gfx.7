.\" Man page generated from reStructuredText.
.
.TH MGSIMDEV-GFX 7 "August 2012" "3.4.90-5937" ""
.SH NAME
mgsimdev-gfx \- Graphical framebuffer pseudo-device in MGSim
.
.nr rst2man-indent-level 0
.
.de1 rstReportMargin
\\$1 \\n[an-margin]
level \\n[rst2man-indent-level]
level margin: \\n[rst2man-indent\\n[rst2man-indent-level]]
-
\\n[rst2man-indent0]
\\n[rst2man-indent1]
\\n[rst2man-indent2]
..
.de1 INDENT
.\" .rstReportMargin pre:
. RS \\$1
. nr rst2man-indent\\n[rst2man-indent-level] \\n[an-margin]
. nr rst2man-indent-level +1
.\" .rstReportMargin post:
..
.de UNINDENT
. RE
.\" indent \\n[an-margin]
.\" old: \\n[rst2man-indent\\n[rst2man-indent-level]]
.nr rst2man-indent-level -1
.\" new: \\n[rst2man-indent\\n[rst2man-indent-level]]
.in \\n[rst2man-indent\\n[rst2man-indent-level]]u
..
.SH DESCRIPTION
.sp
The graphical display is a 2D pixel\-oriented output device. It
provides a linear framebuffer, without output to screen at a fixed set
of SVGA resolutions.
.sp
An I/O device of this type can be specified in MGSim using the device
type \fBGFX\fP\&.
.SH CONFIGURATION
.INDENT 0.0
.TP
.B \fBGfxFrameSize\fP
Size of the framebuffer memory in bytes.
.TP
.B \fBGfxEnableSDLOutput\fP
Enable rendering the framebuffer to screen outside of the
simulation. When this is not enabled, software running on the
simulated platform can update the framebuffer but no pixels are
displayed on screen.
.TP
.B \fBSDLHorizScale\fP, \fBSDLVertScale\fP
How many pixels on the real screen to use to display each pixel in
the framebuffer. These parameters can be adjusted at run\-time, see
\fI\%On the host side of the simulation\fP below.
.TP
.B \fBSDLRefreshDelay\fP
Defines how many simulation cycles to wait between updates to the
output display, when enabled. Can be adjusted at run\-time.
.UNINDENT
.SH PROTOCOL
.SS Changing the display mode
.sp
When read from, words 1\-3 indicate the current display mode.
.sp
The following process configures a new mode:
.INDENT 0.0
.IP 1. 3
the desired mode is written into words 1\-3 of the control device;
.IP 2. 3
the command word 0 is written to, to commit the desired mode;
.IP 3. 3
the words 1\-3 are read back to check whether the mode was accepted.
.UNINDENT
.sp
Invalid mode configurations are ignored and leave the previous mode
unchanged.
.sp
The following sections detail what configurations are accepted.
.SS Pixel modes
.sp
The desired pixel mode is written at word offset 3 of the control
device (see \fI\%INTERFACE\fP below), then committed by writing to
word 0. The following modes are recognized:
.TS
center;
|l|l|l|l|.
_
T{
Bits 0\-15
T}	T{
Bits 16\-31
T}	T{
Value
T}	T{
Resulting pixel mode
T}
_
T{
8
T}	T{
0
T}	T{
8
T}	T{
RGB 2\-3\-3
T}
_
T{
8
T}	T{
1
T}	T{
65544
T}	T{
8\-bit indexed
T}
_
T{
16
T}	T{
0
T}	T{
16
T}	T{
RGB 5\-6\-5
T}
_
T{
24
T}	T{
0
T}	T{
24
T}	T{
RGB 8\-8\-8
T}
_
T{
32
T}	T{
0
T}	T{
32
T}	T{
RGB 8\-8\-8, upper 8 bits ignored
T}
_
.TE
.sp
When in RGB mode, the color components of the output pixels are
defined by the bits in the framebuffer. For example in pixel mode 24,
3 adjacent bytes in the framebuffer define one pixel on screen, with
the first byte for red, 2nd byte for green, 3rd byte for blue. With
pixel mode 8, one byte of the framebuffer is decomposed as 3 values,
one value of 2 bits for red (bits 6\-7), one value of 3 bits for green
(bits 4\-6), and one value of 3 bits for blue (bits 1\-3).
.sp
When in indexed mode, the value in the framebuffer is used as an index
in a palette which is defined separately from the framebuffer (in the
control device). The palette then defines which R/G/B values to use.
.sp
The current pixel mode can be read from word 3 of the control device.
.SS Color palette for indexed modes
.sp
The palette is defined at words 256 onwards in the control
device. Word 256 corresponds to palette index 0, word 257 to palette
index 1, and so on.
.sp
The palette can be both read from and written to, even without setting
a new mode.
.SS Output screen resolution
.sp
The desired output screen width and height in pixels are set at word
offsets 1 and 2 of the control device, respectively (see \fI\%INTERFACE\fP
below), then committed by writing to word 0.
.sp
The values in words 6 and 7 indicate the maximum supported resolution.
.sp
The desired resolution is rounded up to the nearest valid resolution,
which must be one of the following: 10x10, 100x100, 160x100, 160x120,
320x200, 320x240, 640x400, 640x480, 800x600, 1024x768, 1280x1024.
.sp
The effect of setting an output resolution higher than the capacity of
the framebuffer is undefined.
.SS Changing mode vs clearing screen
.sp
As described above, writing to word 0 of the control device sets a new
display mode.
.sp
If the value 0 is written to word 0, the new mode is set but the
framebuffer is preserved.
.sp
If the value 1 is written, the new mode is set \fIand\fP the framebuffer
is cleared.
.SS Screen dump
.sp
When the current pixel mode is 32 (RGB 8\-8\-8), writing to control word
4 outputs the framebuffer content to an portable pixmap (PPM) image in
the simulation\(aqs host environment.
.sp
The value written to control word 4 further configures the screen
dump, as follows:
.INDENT 0.0
.IP \(bu 2
bits 0\-1 determine where the PPM data is output to. The value 0
causes the data to be output to a file. The value 1 causes the data
to be printed to MGSim\(aqs standard output stream. The value 2 outputs
to MGSim\(aqs standard error stream.
.IP \(bu 2
bit 8 determines whether to embed a timestamp in the file name when
bits 0\-1 are set to 0.
.UNINDENT
.SH INTERFACE
.sp
The pseudo\-device presents itself to the I/O bus as two logical
devices: the \fIcontrol\fP interface and the \fIframebuffer\fP interface.
.sp
When multiple graphical outputs are connected to a bus, the device
identifier of the framebuffers can be matched to their control devices
via word 9 of the control device. (see below).
.SS Control device
.sp
The gfx control device must be accessed using 32\-bit I/O
operations. Its device address space is as follows:
.TS
center;
|l|l|l|.
_
T{
32\-bit word
T}	T{
Mode
T}	T{
Description
T}
_
T{
0
T}	T{
R
T}	T{
Boolean: indicates whether the physical screen is connected
T}
_
T{
0
T}	T{
W
T}	T{
Command: commit the mode configured using words 1\-3, non\-zero clears screen
T}
_
T{
1
T}	T{
R
T}	T{
Current width in pixels
T}
_
T{
1
T}	T{
W
T}	T{
Desired width in pixels
T}
_
T{
2
T}	T{
R
T}	T{
Current height in pixels
T}
_
T{
2
T}	T{
W
T}	T{
Desired height in pixels
T}
_
T{
3
T}	T{
R
T}	T{
Current pixel mode (see below)
T}
_
T{
3
T}	T{
W
T}	T{
Desired pixel mode (see below)
T}
_
T{
4
T}	T{
W
T}	T{
Command: dump the framebuffer contents
T}
_
T{
5
T}	T{
R/W
T}	T{
Image index (key) for the next dump
T}
_
T{
6
T}	T{
R
T}	T{
Maximum supported width
T}
_
T{
7
T}	T{
R
T}	T{
Maximum supported height
T}
_
T{
8
T}	T{
R
T}	T{
Screen refresh interval in bus clock cycles
T}
_
T{
9
T}	T{
R
T}	T{
Device identifier of the corresponding framebuffer device on the I/O bus
T}
_
T{
256\-511
T}	T{
R/W
T}	T{
Color palette (one 32\-bit word per color index)
T}
_
.TE
.SS Framebuffer device
.sp
The framebuffer device can be accessed using any I/O data width, as
long as no address past the framebuffer size is accessed.
.sp
The data in the framebuffer is organized as per the \fI\%Pixel modes\fP
explained above, using row\-major addressing (horizontally adjacent
pixels have consecutive addresses in the device address space).
.SS On the host side of the simulation
.sp
When the screen output is enabled, the following keystrokes are
recognized:
.INDENT 0.0
.TP
.B Escape
Closes the display.
.TP
.B Page down / Page up
Modify the scaling factor quickly (how many output pixels are used
to display each logical pixel)
.TP
.B Home / End
Modify the scaling factor slowly.
.TP
.B Tab
Restore the aspect ratio (set the horizontal scaling factor equal
to the vertical factor).
.TP
.B Up / Down
Increase / decrease the refresh delay (refresh rate).
.TP
.B R
Reset the delay and scaling factor to the base configuration.
.UNINDENT
.sp
Moreover, the display window can be interactively resized using the
regular window size manipulation method (eg mouse) to adjust the
scaling factor at a finer grain.
.SH SEE ALSO
.sp
mgsim(1), mgsimdoc(7)
.SH BUGS
.sp
Report bugs & suggest improvements to \fI\%microgrids@svp\-home.org\fP\&.
.SH AUTHOR
MGSim was created by Mike Lankamp. MGSim is now under
stewardship of the Microgrid project. This manual page was written
by Raphael 'kena' Poss.
.SH COPYRIGHT
Copyright (C) 2008-2012 the Microgrid project.
.\" Generated by docutils manpage writer.
.
